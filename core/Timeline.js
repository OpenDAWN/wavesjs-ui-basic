'use strict'

/**
 *
 * The `timeline` is the main entry point of a temporal visualization.
 *
 * The `timeline`:
 * - contains factories to manage its `views` and `layers`,
 * - is the central hub for all user interaction events (keyboard, mouse),
 * - holds the current interaction `state` which defines how the different timeline elements (views, layers, shapes) respond to those events.
 *
 *
 * The `Timeline` class is the main entry point to create a representation of temporal data.
 * A `Timeline` instance can have multiples `Track` instances, which are basically a track window on the overall timeline.
 *
 * The timeline hold the current interaction state and is the central hub for keyboard as well as mouse events.
 * States are there to facilitating interactions with the timeline for:
 * - zooming
 * - moving
 * - editing
 *
 * Methods `register`, `render` and `update` call the same methods on all the `Track` instances, which call the same methods one on all its `Layer` instances.
 * - `register`: registers a `Track` instance onto the timeline (ie. the timeline can `render` and `update` its different tracks)
 * - `render`: renders the DOM for the element (if has one) and its descendant (here renders the tracks, ie. render the DOM tree for a track and attach it in the DOM at the right place)
 * - `update`: update the display according to data changes (ie. update the DOM element attached to the DOM tree with render method, based on new data).
 */
function Timeline(pixelsPerSecond, visibleWidth) {

	EventEmitter.call(this);

	if (pixelsPerSecond == undefined) 
		pixelsPerSecond = 100;

	if (visibleWidth == undefined)
		visibleWidth = 1000;

	// public attributes
	this._tracks = new TrackCollection(this);

    this._state = null;
    this._handleEvent = this._handleEvent.bind(this);
    this._createInteraction(Keyboard, 'body');
    // stores
    this._trackById = {};
    this._groupedLayers = {};

    this.timeContext = new TimelineTimeContext(pixelsPerSecond, visibleWidth);


	Object.defineProperties(this, {

		/**
		 *  TimeContext accessors
		 */
		'offset' : {
			get: function() {
				return this.timeContext.offset;
			},
			set: function(value) {
				this.timeContext.offset = value;
			}
		}, 
		
		'zoom' : {
			get: function() {
				return this.timeContext.zoom;
			}, 
			set: function(value) {
				this.timeContext.zoom = value;
			}
		}, 

		'pixelsPerSecond' : {
			get: function() {
				return this.timeContext.pixelsPerSecond;
			}, 
			set: function(value) {
				this.timeContext.pixelsPerSecond = value;
			}
		},

		// @readonly
		'visibleDuration' : {
			get: function() {
				return this.timeContext.visibleWidth;
			}
		},

		'visibleWidth' : {
			get: function() {
				return this.timeContext.visibleWidth;
			}, 
			set: function(value) {
				this.timeContext.visibleWidth = value;
			}
		},

		// @NOTE maybe expose as public instead of get/set for nothing...
		'maintainVisibleDuration' : {
			get: function() {
				return this.timeContext.maintainVisibleDuration;
			}, 
			set: function(bool) {
				this.timeContext.maintainVisibleDuration = bool;
			}
		},

		// @readonly - used in track collection
		'groupedLayers' : {
			get: function() {
				return this._groupedLayers;
			}
		},

		/**
		 * Changes the state of the timeline
		 * @param {BaseState} state - the state in which the timeline must be setted
		 */
		'state' : {
			get: function() {
				return this._state;
			}, 
			set: function(state) {
				if (this._state) { 
					this._state.exit(); 
				}
				this._state = state;
				this._state.enter();
			}
		},

		/**
		 *  Shortcut to access the Track collection
		 *  @return {TrackCollection}
		 */
		'tracks' : {
			get: function() {
				return this._tracks;
			}
		},

		/**
		 * Shortcut to access the Layer list
		 * @return {Array}
		 */
		'layers' : {
			get: function() {
				return this._tracks.layers;
			}
		}
	});

	// TODO: TRANSLATE THIS INTO "NORMAL" JAVASCRIPT
	// *[Symbol.iterator]() {
	// 	yield* this.tracks[Symbol.iterator]();
	// }
}

Timeline.prototype = Object.create(EventEmitter.prototype);

Timeline.prototype.constructor = Timeline;

/**
 * Factory method to add interaction modules the timeline should listen to.
 * By default, the timeline listen to Keyboard, and instance a Surface on each container
 * @param {EventSource} ctor - the contructor of the interaction module to instanciate
 * @param el {DOMElement} the DOM element to bind to the EventSource module
 * @param options {Object} options to be applied to the ctor (defaults to `{}`)
 */
Timeline.prototype._createInteraction = function(ctor, el, options) {
	if (options == undefined)
		options = {};

	const interaction = new ctor(el, options);
	interaction.on('event', this._handleEvent);
}

/**
 * The callback that is used to listen to interactions modules
 * @params {Event} e - a custom event generated by interaction modules
 */
Timeline.prototype._handleEvent = function(e) {
	// emit event as a middleware
	this.emit('event', e);
	// propagate to the state
	if (!this._state) { 
		return; 
	}
	this._state.handleEvent(e);
}




/**
 * Adds a track to the timeline
 * Tracks display this window on the timeline in theirs own SVG element.
 * @param {Track} track
 */
Timeline.prototype.add = function(track) {
	if (this.tracks.indexOf(track) !== -1) {
		throw new Error('track already added to the timeline');
	}

	track.configure(this.timeContext);

	this.tracks.push(track);
	this._createInteraction(Surface, track.$el);
}

Timeline.prototype.remove = function(track) {
	// @TODO
}

/**
 *  Creates a new track from the configuration define in `configureTracks`
 *  @param {DOMElement} $el - the element to insert the track inside
 *  @param {Object} options - override the defaults options if necessary
 *  @param {String} [trackId=null] - optionnal id to give to the track, only exists in timeline's context
 *  @return {Track}
 */
Timeline.prototype.createTrack = function($el, trackHeight, trackId) {
	
	if (trackHeight == undefined)
		trackHeight = null;

	if (trackId == undefined)
		trackId = null;

	const track = new Track($el, trackHeight);

	if (trackId !== null) {
		if (this._trackById[trackId] !== undefined) {
			throw new Error("trackId: " + trackId + " is already used");
		}

		this._trackById[trackId] = track;
	}
	// add track to the timeline
	this.add(track);
	return track;
}

/**
 *  Adds a layer to a track, allow to group track arbitrarily inside groups. Basically a wrapper for `track.add(layer)`
 *  @param {Layer} layer - the layer to add
 *  @param {Track} track - the track to the insert the layer in
 *  @param {String} [groupId='default'] - the group in which associate the layer
 */
Timeline.prototype.addLayer = function(layer, trackOrTrackId, groupId) {

	if (groupId == undefined)
		groupId = 'default';

	let track = trackOrTrackId;

	if (typeof trackOrTrackId === 'string') {
		track = this.getTrackById(trackOrTrackId);
	}
	// we should have a Track instance at this point
	track.add(layer);

	if (!this._groupedLayers[groupId]) {
		this._groupedLayers[groupId] = [];
	}

	this._groupedLayers[groupId].push(layer);
}

/**
 *  Removes a layer from its track (the layer is detatched from the DOM but can still be reused)
 *  @param {Layer} layer - the layer to remove
 */
Timeline.prototype.removeLayer = function(layer) {
	this.tracks.forEach(function(track) {
		const index = track.layers.indexOf(layer);
		if (index !== -1) { 
			track.remove(layer); 
		}
	});

	for (let groupId in this._groupedLayers) {
		const group = this._groupedLayers[groupId];
		const index = group.indexOf(layer);

		if (index !== -1) { 
			group.splice(layer, 1); 
		}

		if (!group.length) {
			delete this._groupedLayers[groupId];
		}
	}
}

/**
 *  Returns a track from it's id
 *  @param {String} trackId
 *  @return {Track}
 */
Timeline.prototype.getTrackById = function(trackId) {
	return this._trackById[trackId];
}

/**
 * Returns an array of layers from their group Id
 * @param {String} groupId
 * @return {Array}
 */
Timeline.prototype.getLayersByGroup = function(groupId) {
	return this._groupedLayers[groupId];
}